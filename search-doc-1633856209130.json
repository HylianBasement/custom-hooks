[{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Git Submodule","type":1,"pageTitle":"Installation","url":"docs/Installation#git-submodule","content":"Clone the repository and add it as a git submodule.Configure your rojo project file to point to the appropriate path. (reference here) "},{"title":"Wally","type":1,"pageTitle":"Installation","url":"docs/Installation#wally","content":"Coming soon. "},{"title":"Roblox-TS","type":1,"pageTitle":"Installation","url":"docs/Installation#roblox-ts","content":"Just run npm i @rbxts/hook-bag and you are done! "},{"title":"Table of Contents","type":0,"sectionRef":"#","url":"docs/intro","content":"Table of Contents InstallationAPI Reference","keywords":""},{"title":"Hooks","type":0,"sectionRef":"#","url":"api/Hooks","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Hooks","url":"api/Hooks#types","content":" "},{"title":"HookCreator<T>","type":1,"pageTitle":"Hooks","url":"api/Hooks#HookCreator<T>","content":"&lt;/&gt; type HookCreator&lt;T&gt; = (hooks: RoactHooks) → T   "},{"title":"PortalOptions","type":1,"pageTitle":"Hooks","url":"api/Hooks#PortalOptions","content":"&lt;/&gt; interface PortalOptions { Target: Instance DefaultShow: boolean | nil DisplayName: string | nil DisplayOrder: number | nil IgnoreGuiInset: boolean | nil OnShow: (() → void) | nil OnHide: (() → void) | nil OnClickOutside: ((hide: () → void) → void) | nil }   "},{"title":"UseArray<T>","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseArray<T>","content":"&lt;/&gt; interface UseArray&lt;T&gt; { array: {T} set: (valueOrCallback: T | (array: T) → T) → void push: (...elements: T) → void filter: (callback: ( element: T, index: number ) → boolean) → void update: ( index: number, element: T ) → void remove: (index: number) → void clear: () → void }   "},{"title":"UseAsync<T>","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseAsync<T>","content":"&lt;/&gt; interface UseAsync&lt;T&gt; { isLoading: boolean isCancelled: boolean didError: boolean result: T }   "},{"title":"UseCounter","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseCounter","content":"&lt;/&gt; type UseCounter = ( number, () → void, () → void, () → void )   "},{"title":"UseFlipper","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseFlipper","content":"&lt;/&gt; type UseFlipper = ( RoactBinding&lt;number&gt;, FlipperMotor )   "},{"title":"UsePortal","type":1,"pageTitle":"Hooks","url":"api/Hooks#UsePortal","content":"&lt;/&gt; interface UsePortal { Portal: Roact.FunctionComponent isShow: boolean show: () → void hide: () → void toggle: () → void }   "},{"title":"UseQueue<T>","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseQueue<T>","content":"&lt;/&gt; interface UseQueue&lt;T&gt; { add: (element: T) → void remove: () → void first: T | nil last: T | nil size: number }   "},{"title":"UseTimeout","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseTimeout","content":"&lt;/&gt; interface UseTimeout { cancel: () → void reset: () → void }   "},{"title":"UseToggle","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseToggle","content":"&lt;/&gt; type UseToggle = ( boolean, (value: boolean | nil) → void )   "},{"title":"UseTween","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseTween","content":"&lt;/&gt; interface UseTween { play: () → void pause: () → void cancel: () → void onCompleted: (callback: (playbackState: Enum.PlaybackState) → void) → void }   "},{"title":"UseUndo<T>","type":1,"pageTitle":"Hooks","url":"api/Hooks#UseUndo<T>","content":"&lt;/&gt; interface UseUndo&lt;T&gt; { set: (newPresent: T) → void reset: (newPresent: T) → void undo: () → void redo: () → void canUndo: boolean canRedo: boolean }  "},{"title":"Functions","type":1,"pageTitle":"Hooks","url":"api/Hooks#functions","content":" "},{"title":"useArray","type":1,"pageTitle":"Hooks","url":"api/Hooks#useArray","content":"&lt;/&gt; Hooks.useArray(initialValue: {T} | nil) → HookCreator&lt;UseArray&lt;T&gt;&gt; Lets you manipulate an array data structure without ever needing extra utilities. local function HookedComponent(props, hooks) local text = hooks.useValue() local list = useArray({})(hooks) return Roact.createFragment({ Button = Roact.createElement(&quot;TextButton&quot;, { -- ... Text = &quot;Add&quot;, [Roact.Event.MouseButton1Click] = function(rbx) if text.value then list.push(text.value) end text.value = nil end }), TextBox = Roact.createElement(&quot;TextBox&quot;, { -- ... Text = &quot;&quot;, [Roact.Change.Text] = function(rbx) text.value = rbx.Text end }), Display = Roact.createElement(&quot;Frame&quot;, { -- ... }, { Layout = Roact.createElement(&quot;UIListLayout&quot;, { -- ... }), Roact.createFragment(list.array) }) }) end   "},{"title":"useAsync","type":1,"pageTitle":"Hooks","url":"api/Hooks#useAsync","content":"promise &lt;/&gt; Hooks.useAsync(asyncCallback: () → Promise&lt;T&gt;) → HookCreator&lt;UseAsync&lt;T&gt;&gt; Handles async operations and prevents race conditions. local function fetchData() return Promise.new(function() return httpRequest(&quot;http://url...&quot;) end) end local function HookedComponent(props, hooks) local async = useAsync(fetchData)(hooks) return Roact.createFragment({ Loading = async.isLoading and Roact.createElement(...), Error = async.error and Roact.createElement(...), Result = async.result and Roact.createElement(...) }) end   "},{"title":"useCounter","type":1,"pageTitle":"Hooks","url":"api/Hooks#useCounter","content":"&lt;/&gt; Hooks.useCounter(initialValue: number | nil) → HookCreator&lt;UseCounter&gt; State hook that tracks a numeric value. If no initial value is passed, it will default to 0. tip Counters can be increased/decreased by amount if you pass a number to it's function. local function HookedComponent(props, hooks) local count, increment, decrement, reset = useCounter()(hooks) return Roact.createFragment({ Counter = Roact.createElement(MyCounter, { Text = tostring(count) }), Inc = Roact.createElement(Button, { OnClick = function() increment() end }), Dec = Roact.createElement(Button, { OnClick = function() decrement() end }), Reset = Roact.createElement(Button, { OnClick = function() reset() end }), }) end   "},{"title":"useDebounce","type":1,"pageTitle":"Hooks","url":"api/Hooks#useDebounce","content":"promise &lt;/&gt; Hooks.useDebounce( time: number, callback: () → void, dependencies: {any} ) → HookCreator&lt;( () → boolean, () → void )&gt; Hook that delays invoking a function until after wait seconds have elapsed since the last time the debounced function was invoked. The third argument is the array of values that the debounce depends on, in the same manner as useEffect. The debounce timeout will start when one of the values changes. tip You can reach the same result using the hook below. local function HookedComponent(props, hooks) local text, setText = hooks.useState(&quot;&quot;) local debouncedText, setDebouncedText = hooks.useState(text) -- Will change debouncedText and render after 1 second of inactivity useDebounce(1, function() setDebouncedText(text) end, { text })(hooks) return Roact.createFragment({ Label = Roact.createElement(Label, { Text = debouncedText }), Box = Roact.createElement(&quot;TextBox&quot;, { -- ..., [Roact.Change.Text] = function(rbx) setText(rbx.Text) end }), }) end   "},{"title":"useDebouncedText","type":1,"pageTitle":"Hooks","url":"api/Hooks#useDebouncedText","content":"promise &lt;/&gt; Hooks.useDebouncedText( time: number, text: string ) → HookCreator&lt;string&gt; A shortcut for using useDebounce with a string. local function HookedComponent(props, hooks) local text, setText = hooks.useState(&quot;&quot;) local debouncedText = useDebouncedText(1, text)(hooks) return Roact.createFragment({ Label = Roact.createElement(Label, { Text = debouncedText }), Box = Roact.createElement(&quot;TextBox&quot;, { -- ..., [Roact.Change.Text] = function(rbx) setText(rbx.Text) end }), }) end   "},{"title":"useDispatch","type":1,"pageTitle":"Hooks","url":"api/Hooks#useDispatch","content":"roact-rodux rodux &lt;/&gt; Hooks.useDispatch(hooks: RoactHooks) → () → void Returns a reference to the dispatch function from the store. You may use it to dispatch actions as needed. local function Counter(props, hooks) local dispatch = useDispatch(hooks) return Roact.createFragment({ Label = Roact.createElement(&quot;TextLabel&quot;, { Text = props.value }), Increment = Roact.createElement(Button, { OnClick = function() dispatch({ type = &quot;increment&quot; }) end }) }) end   "},{"title":"useFlipper","type":1,"pageTitle":"Hooks","url":"api/Hooks#useFlipper","content":"flipper &lt;/&gt; Hooks.useFlipper(motor: FlipperMotor) → HookCreator&lt;UseFlipper&gt; Helper hook that takes a flipper motor, connects it to a binding and returns both.  "},{"title":"useForceUpdate","type":1,"pageTitle":"Hooks","url":"api/Hooks#useForceUpdate","content":"&lt;/&gt; Hooks.useForceUpdate(hooks: RoactHooks) → () → void Returns a callback that once called, will cause the component to re-render.  "},{"title":"useLatest","type":1,"pageTitle":"Hooks","url":"api/Hooks#useLatest","content":"&lt;/&gt; Hooks.useLatest(value: T) → HookCreator&lt;{value: T}&gt; Hook that can be used to return the latest state. tip This is useful to get access to the latest version of a value, instead of getting the version from the time an asynchronous callback was created, for example. local function Demo(props, hooks) local count, increment = useCounter()(hooks) local latestCount = useLatest(count)(hooks) useTimeout(5, function() print((&quot;Latest count is: %s&quot;):format(latestCount.value)) end)(hooks) return Roact.createFragment({ Label = Roact.createElement(Label, { Text = tostring(count) }), Button = Roact.createElement(Button, { OnClick = function() increment() end }) }) end   "},{"title":"useMaid","type":1,"pageTitle":"Hooks","url":"api/Hooks#useMaid","content":"maid &lt;/&gt; Hooks.useMaid( maid: Maid, dependencies: {any} ) → HookCreator&lt;void&gt; Will clear the maid after one of its dependencies change. TODO EXAMPLE  "},{"title":"usePortal","type":1,"pageTitle":"Hooks","url":"api/Hooks#usePortal","content":"roact &lt;/&gt; Hooks.usePortal(options: PortalOptions) → HookCreator&lt;UsePortal&gt; This helps you render children into an element that exists outside the hierarchy of the parent component. TODO EXAMPLE  "},{"title":"usePrevious","type":1,"pageTitle":"Hooks","url":"api/Hooks#usePrevious","content":"&lt;/&gt; Hooks.usePrevious(state: S) → HookCreator&lt;S&gt; Simply returns the previous state.  "},{"title":"useQueue","type":1,"pageTitle":"Hooks","url":"api/Hooks#useQueue","content":"&lt;/&gt; Hooks.useQueue(initialValue: {T}) → HookCreator&lt;UseQueue&lt;T&gt;&gt; State hook that implements a simple FIFO queue.  "},{"title":"useReactiveState","type":1,"pageTitle":"Hooks","url":"api/Hooks#useReactiveState","content":"&lt;/&gt; Hooks.useReactiveState(initialState: T) → HookCreator&lt;T&gt; Creates a state object that can be changed whenever a new value is assigned to a key.  "},{"title":"useRendersSpy","type":1,"pageTitle":"Hooks","url":"api/Hooks#useRendersSpy","content":"&lt;/&gt; Hooks.useRendersSpy(hooks: RoactHooks) → number Returns the amount of renders the component has since its mount.  "},{"title":"useSelector","type":1,"pageTitle":"Hooks","url":"api/Hooks#useSelector","content":"roact-rodux rodux &lt;/&gt; Hooks.useSelector( selector: (state: S) → R, equalityFn: (( a: any, b: any ) → boolean) | nil ) → HookCreator&lt;R&gt; Allows you to extract data from the store state, using a selector function. warning Selectors should be pure since they are potentially executed multiple times and at arbitrary points in time.  "},{"title":"useStore","type":1,"pageTitle":"Hooks","url":"api/Hooks#useStore","content":"roact-rodux rodux &lt;/&gt; Hooks.useStore(hooks: RoactHooks) → Store Returns a reference to the same store that was passed in to the StoreProvider component. caution This should not be used frequently. If you just want to retrieve data from the store, prefer useSelector instead.  "},{"title":"useTimeout","type":1,"pageTitle":"Hooks","url":"api/Hooks#useTimeout","content":"promise &lt;/&gt; Hooks.useTimeout( time: number, callback: () → void, onCancel: ((timeLeft: number) → void) | nil ) → HookCreator&lt;UseTimeout&gt; Re-renders the component after a specified number of seconds. Provides handles to cancel and/or reset the timeout. info This is a one time call. Once the timeout is finished, you cannot use it again. If you are looking into something that can change accordingly to its dependencies, check useDebounce. local function HookedComponent(props, hooks) local text, setText = useState(&quot;&quot;) local timeout = useTimeout(3, function() setText(&quot;This took 3 seconds!&quot;) end)(hooks) return Roact.createElement(&quot;TextLabel&quot;, { -- ... Text = text, }) end   "},{"title":"useToggle","type":1,"pageTitle":"Hooks","url":"api/Hooks#useToggle","content":"&lt;/&gt; Hooks.useToggle(initialValue: boolean) → HookCreator&lt;UseToggle&gt; State hook that tracks value of a boolean.  "},{"title":"useTween","type":1,"pageTitle":"Hooks","url":"api/Hooks#useTween","content":"&lt;/&gt; Hooks.useTween(tweenInfo: TweenInfo) → HookCreator&lt;( RoactBinding&lt;number&gt;, UseTween )&gt; Takes a TweenInfo class and returns a binding and an object to manage the tweening. TODO EXAMPLE  "},{"title":"useUndo","type":1,"pageTitle":"Hooks","url":"api/Hooks#useUndo","content":"&lt;/&gt; Hooks.useUndo(initialPresent: T) → HookCreator&lt;( T, UseUndo&lt;T&gt; )&gt; Stores defined amount of previous state values and provides handles to travel through them. TODO EXAMPLE  "},{"title":"useUpdateEffect","type":1,"pageTitle":"Hooks","url":"api/Hooks#useUpdateEffect","content":"&lt;/&gt; Hooks.useUpdateEffect( callback: () → (() → void) | void, dependencies: {any} | nil ) → HookCreator&lt;void&gt; Does the exactly same thing useEffect do, but ignores the first render. "}]